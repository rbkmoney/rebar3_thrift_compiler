-module(rebar3_thrift_compiler_prv_clean).

-export([init/1, do/1, format_error/1]).

%% Public API

-spec init(rebar_state:t()) -> {ok, rebar_state:t()}.

init(State) ->
    Provider = providers:create([
        {name, 'clean'},
        {namespace, 'thrift'},
        {module, ?MODULE},
        {bare, true},
        {deps, [{default, app_discovery}]},
        {example, "rebar3 thrift clean"},
        {short_desc, "Clean artifacts of Thrift IDL compilation process"},
        {desc,
            "Clean artifacts of Thrift IDL compilation process."
            "\n\n"
            "Cleanup process will try to scan the contents of `out_erl_dir` and `out_hrl_dir` "
            "and exterminate everything that looks like Thrift compilation artifacts. "
            "If somewhere in the first three lines there is a string that looks like "
            "'Autogenerated by <...>' then this file with accompanying header file with the "
            "same basename is marked for deletion."
            "\n\n"
            "Options available in `rebar.config`:"
            "\n\n"
            "  {thrift_compiler_opts, [\n"
            "    {out_erl_dir, \"src\"},    % where *.erl files reside\n"
            "    {out_hrl_dir, \"include\"} % where *.hrl files reside\n"
            "  ]}."
            "\n"
        },
        {opts, opts()}
    ]),
    {ok, rebar_state:add_provider(State, Provider)}.

opts() ->
    [
        {out_erl_dir, $o, "erlout", string,
            "Directory where generated *.erl files reside, relative to application output directory"
            " (default = \"src\")"
        },
        {out_hrl_dir, $O, "hrlout", string,
            "Directory where generated *.hrl files reside, relative to application output directory"
            " (default = \"include\")"
        }
    ].

-spec do(rebar_state:t()) -> {ok, rebar_state:t()} | {error, string()}.

do(State) ->
    CmdOpts = rebar_state:command_parsed_args(State),
    ok = lists:foreach(
        fun (AppInfo) -> rebar3_thrift_compiler_prv:clean(AppInfo, CmdOpts) end,
        get_apps(State)
    ),
    {ok, State}.

-spec get_apps(rebar_state:t()) -> [rebar_app_info:t()].

get_apps(State) ->
    case rebar_state:current_app(State) of
        undefined ->
            rebar_state:project_apps(State);
        AppInfo ->
            [AppInfo]
    end.

-spec format_error(any()) ->  iolist().

format_error(Reason) ->
    io_lib:format("~p", [Reason]).
